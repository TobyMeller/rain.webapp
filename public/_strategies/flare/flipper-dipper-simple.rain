raindex-version: f60e99a7180aa8c82e7197a25c80dbb0c3277d46

gui:
  name: Flipper dippers
  description: Dave please write this.
  deployments: 
    - deployment: flare
      name: Flip and Dip
      description: Stable soup
      fields:
        - binding: io-multiplier
          name: IO multiplier
          description: IO multiplier
          presets:
            - 0.005
            - 0.01
            - 0.015
      deposits:
        - token: usdce
          min: 20
          presets:
            - 0.01
            - 50
            - 100
        - token: usdt
          min: 20
          presets:
            - 0.01
            - 50
            - 100

networks:
  flare:
    rpc: https://rpc.ankr.com/flare
    chain-id: 14 
    network-id: 14 
    currency: FLR
metaboards:
  flare: https://api.goldsky.com/api/public/project_clv14x04y9kzi01saerx7bxpg/subgraphs/mb-flare-0x893BBFB7/0.1/gn
subgraphs:
  flare: https://api.goldsky.com/api/public/project_clv14x04y9kzi01saerx7bxpg/subgraphs/ob4-flare/0.2/gn
orderbooks:
  flare: 
    address: 0xCEe8Cd002F151A536394E564b84076c41bBBcD4d
deployers:
  flare:
    address: 0xE3989Ea7486c0F418C764e6c511e86f6E8830FAb

tokens:
  usdce:
    network: flare
    address: 0xFbDa5F676cB37624f28265A144A48B0d6e87d3b6
    decimals: 6
  usdt:
    network: flare
    address: 0x0B38e83B86d491735fEaa0a791F65c2B99535396
    decimals: 6
  usdx:
    network: flare
    address: 0x4A771Cc1a39FDd8AA08B8EA51F7Fd412e73B3d2B
    decimals: 6

orders:
  flare:
    orderbook: flare
    network: flare
    inputs:
      - token: usdce
      - token: usdt
      - token: usdx
    outputs:
      - token: usdce
      - token: usdt
      - token: usdx

scenarios:
  flare:
    orderbook: flare
    runs: 1
    bindings:
      time-per-epoch-init: 10800
      initial-max-additional-io: 0.06
      initial-baseline-io: 0.97

      time-per-epoch-trading: 10800
      io-multiplier: 0.01

charts:
  flare:

deployments:
  flare:
    order: flare
    scenario: flare

---
#raindex-subparser 0xFe2411CDa193D9E4e83A5c234C7Fd320101883aC

#trade-time-ago-key "trade-time-ago-key"

#time-per-epoch-init !Number of seconds per epoch during initialization. An epoch is one halving.
#initial-max-additional-io !IO that is _added_ to the initial baseline IO to start the auction.
#initial-baseline-io !Minimum IO for the initial auction.

#time-per-epoch-trading !Number of seconds per epoch during trading. An epoch is one halving.
#io-multiplier !Multiple of the breakeven io to start each flip at. E.g. 0.2 starts 20% above breakeven.

#handle-add-order
using-words-from
  raindex-subparser
  key:
    hash(order-hash() trade-time-ago-key),
  :set(key now());

#epochs-since-trade
time-per-epoch:,
key:
  hash(order-hash() trade-time-ago-key),
last-time: get(key),
time-ago:
  sub(now() last-time),
epochs:
  div(time-ago time-per-epoch),

:set(key now());

#halflife
max-io epochs:,
/**
 * Shrinking the multiplier like this
 * then applying it 10 times allows for
 * better precision when max-io-ratio
 * is very large, e.g. ~1e10 or ~1e20+
 *
 * This works because `power` loses
 * precision on base `0.5` when the
 * exponent is large and can even go
 * to `0` while the io-ratio is still
 * large. Better to keep the multiplier
 * higher precision and drop the io-ratio
 * smoothly for as long as we can.
 */
multiplier:
  power(0.5 div(epochs 10)),
io:
  mul(
    max-io
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
    multiplier
  );

#breakeven-io
prev-input-vault-balance:
  get(hash(order-hash() input-token())),
output-vault-balance: output-vault-before(),

/**
 * This will be `0` initially which is a dangerous edge case
 * as we will naively ask for `0` input and instantly lose
 * all our funds. This needs to be handled carefully.
 *
 * After at least one trade has occurred on this pair it will
 * never be `0` again and so is safe.
 */
io:
  div(prev-input-vault-balance output-vault-balance);

#calculate-io
using-words-from
  raindex-subparser

trading-breakeven-io:
  call<'breakeven-io>(),
baseline-io: any(trading-breakeven-io initial-baseline-io),
max-additional-io:
  if(trading-breakeven-io mul(trading-breakeven-io io-multiplier) initial-max-additional-io),
time-per-epoch:
  if(trading-breakeven-io time-per-epoch-trading time-per-epoch-init),
additional-io:
  call<'halflife>(max-additional-io call<'epochs-since-trade>(time-per-epoch)),
_: max-value(),
_: add(baseline-io additional-io);

#handle-io
  :ensure(output-vault-before() "No output."),
  :ensure(
    equal-to(output-vault-before() output-vault-decrease())
    "Partial clear."
  ),
  :set(
    hash(order-hash() output-token())
    output-vault-before()
  );